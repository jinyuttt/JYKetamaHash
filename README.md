# JYKetamaHash
Hash一致实现负载均衡  
已经上传nuget(JYKetamaHash)
---------------------------------------------------------------------
使用方法：  
1.直接将数据发网服务端  
   hashRing.GetCurrent();  
2.将字符串Key映射到服务端  
   hashRing.GetStoreNode(key)  
3.将其它类型Key映射到服务端  
   byte[]k=你的转换方式(k)  
   hashRing.GetStoreNode(key)   
   需要将Key转换（序列化为byte[])
  
  使用前需要将真实节点插入  
    ConsistencyRing hashRing = new ConsistencyRing();  
    hashRing.AddNode();  

---------------------------------------------------------------------
1.保持以前的代码，主要是网上找到的  
2.优化算法，结合MurmurHash以及红黑树存储，专门的接口。  
3.经测试，在小集合中，使用sortedlist更加高速。  
4.使用了网友的红黑树，但是测试没有意义，红黑树需要遍历返回比当前key大的最近一个，很慢  
5.经整合，在红黑树上添加了sortedlist维持数据，更加高效合理。  
6.当前数据量百万级分片没有意义，源码中有说明。  
7.已经尽可能优化，基本符合功能。所以采用Murmur算法能够加快速度。但是底层集合还是网上的sortedlist合理。  
8.底层sortedlist返回比当前大的key,不能用网上的方法，而是自己写一个二分法查找，网上直接用linq不合理，用plinq也无意义

 2018-12-21整合升级
 --------------------------------------
2.我没有真正理解红黑树的算法含义，所以在使用其满足Hash一致时，没有找到合适的方法返回大于Key并且是最近的那个节点。  
3.最近一天测试，发现有合理快速的办法返回最近的Key(也就是Hash环右侧的Key).很快速，因此恢复了使用红黑树，没有再使用sortedlist。  
4.虽然我提供了TailMap方法，但是测试很慢（不影响Hash一致算法），不知道是不是我还是没有理解红黑树，没有找到最合适的方法返回。该功能是返回大于Key的所有数据节点。  
5.总体说就是除了上次的第4点是错误的，其余还是支持的。  

---------------------------------------------
2018-12-22  
添加了java的实现方法，但是没有使用，只是当做参阅

2018-12-19  
扩展了2个方法方便使用，更加符合c#方式
